# -*- coding: utf-8 -*-
"""Understanding classes and object.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FBb9AhPSpARr2Dz1XIBqmoYHrLu3Oljr

#UNDERSTANDING CLASSES AND OBJECT

================================================================
PART 1: UNDERSTANDING CLASSES AS "BLUEPRINTS" (ATTRIBUTES)
================================================================
Think of a Class as a factory blueprint.
- The Class is the blueprint (e.g., A design for a Laptop).
- The Object is the actual item made from that blueprint (e.g., YOUR laptop).
'''
"""

class Laptop:
    # These are 'Class Attributes'.
    # Every object created from this class starts with these specific values.
    brand = 'Generic Brand'
    ram_gb = 8

# 1. Creating the first object (instance) from the blueprint
l1 = Laptop()

# NOTE: accessing the values that came from the blueprint
print("--- l1 (Default) ---")
print(f"Brand: {l1.brand}")  # Output: Generic Brand
print(f"RAM: {l1.ram_gb}")    # Output: 8

print('-' * 30)

# 2. Modifying the first object
# We are changing l1, but NOT the blueprint.
# This creates 'Instance Attributes' specific only to l1.
l1.brand = 'MacBook Pro'
l1.ram_gb = 16

print("--- l1 (Modified) ---")
print(f"Brand: {l1.brand}")  # Output: MacBook Pro
print(f"RAM: {l1.ram_gb}")    # Output: 16

print('-' * 30)

# 3. Creating a second object (l2)
# Since we didn't change the blueprint (Class), l2 still has the default values.
l2 = Laptop()

print("--- l2 (Fresh Object) ---")
print(f"Brand: {l2.brand}")  # Output: Generic Brand (Unchanged!)
print(f"RAM: {l2.ram_gb}")    # Output: 8

print('*' * 30)

#PART 2: UNDERSTANDING METHODS (BEHAVIOR)
#================================================================
#Classes aren't just for storing data; they can DO things.
#Functions inside a class are called 'Methods'.
#The 'self' keyword allows the code to know WHICH object is calling the function.

class PhysicsSolver:

    # A simple method that prints and returns a value
    # Similar to your 'greet' function
    def status_check(self):
        print('System is Ready...')
        return 'OK'

    # A method containing logic (Looping)
    # Similar to your 'factorial', but this calculates the Sum of numbers (1 to n)
    def sum_natural_numbers(self, n):
        total = 0
        for i in range(1, n + 1):
            total += i  # e.g., 1 + 2 + 3...
        return total

    # A method that processes a single list
    # Similar to your 'lst_mul', but this calculates Average
    def calculate_average(self, lst):
        total_sum = 0
        for i in lst:
            total_sum += i
        return total_sum / len(lst)

    # A method that combines two lists
    # Similar to your 'lst_dot', but this ADDS elements instead of multiplying
    def add_two_lists(self, list_a, list_b):
        # List Comprehension to add element-by-element
        return [list_a[i] + list_b[i] for i in range(len(list_a))]


# 1. Create the tool (the object)
tool = PhysicsSolver()

# 2. Call the simple method
# Notice we don't pass 'self'. Python does that automatically.
print(tool.status_check())
print('-' * 30)

# 3. Call the looping method (Sum of 1 to 5)
# 1+2+3+4+5 = 15
print(f"Sum of 1-5: {tool.sum_natural_numbers(5)}")
print('-' * 30)

# 4. Call the list processor (Average)
# (10+20+30) / 3 = 20.0
print(f"Average: {tool.calculate_average([10, 20, 30])}")
print('-' * 30)

# 5. Call the multi-list processor
# [1+10, 2+20, 3+30] -> [11, 22, 33]
val_1 = [1, 2, 3]
val_2 = [10, 20, 30]
print(f"Added Lists: {tool.add_two_lists(val_1, val_2)}")
print('-' * 30)

"""Key Takeaways for your Notes:
Class vs Object:

class Laptop: is the definition.

l1 = Laptop() is the actual creation. l1 is independent of l2.

self:

In the PhysicsSolver class, every function has self as the first parameter.

When you write tool.status_check(), Python actually runs PhysicsSolver.status_check(tool). It passes the object itself so the code knows who is asking.

Encapsulation:

Notice how the logic (like calculating averages or sums) is hidden inside the tool. The main part of your code stays clean and readable.
"""